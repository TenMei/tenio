package com.tenio.engine.entitas.matcher;

import java.util.Arrays;
import java.util.List;
import java.util.Set;

import com.tenio.engine.entitas.api.entitas.IEntity;
import com.tenio.engine.entitas.api.matcher.IAllOfMatcher;
import com.tenio.engine.entitas.api.matcher.IAnyOfMatcher;
import com.tenio.engine.entitas.api.matcher.IMatcher;
import com.tenio.engine.entitas.api.matcher.INoneOfMatcher;
import com.tenio.engine.entitas.caching.EntitasCache;
import com.tenio.engine.entitas.exceptions.MatcherException;

/**
 * <p>
 * Matchers are generated by the code generator and can be combined. Matchers
 * <br>
 * are usually used to get groups of entities from the context of interest.
 * <br>
 * Remember to prefix the matcher with the context name you are interested (e.g.
 * <br>
 * <tt>GameMatcher, InputMatcher</tt> etc).
 * </p>
 * 
 * @author Rubentxu
 */
public class Matcher<TEntity extends IEntity>
		implements IAllOfMatcher<TEntity>, IAnyOfMatcher<TEntity>, INoneOfMatcher<TEntity> {

	public String[] componentNames;
	
	private int[] __indices;
	private int[] __allOfIndices;
	private int[] __anyOfIndices;
	private int[] __noneOfIndices;
	private int __hash;
	private boolean __hashCached = false;
	
	// prevent creating outside
	private Matcher() {
		
	}

	@Override
	public int[] getIndices() {
		if (__indices == null) {
			__indices = __mergeIndices(__allOfIndices, __anyOfIndices, __noneOfIndices);
		}
		return __indices;
	}

	@Override
	public int[] getAllOfIndices() {
		return __allOfIndices;
	}

	@Override
	public int[] getAnyOfIndices() {
		return __anyOfIndices;
	}

	@Override
	public int[] getNoneOfIndices() {
		return __noneOfIndices;
	}

	@Override
	public IAnyOfMatcher<TEntity> anyOf(int... indices) {
		__anyOfIndices = __distinctIndices(indices);
		__indices = null;
		__hashCached = false;
		return this;
	}

	@Override
	public IAnyOfMatcher<TEntity> anyOf(@SuppressWarnings("unchecked") IMatcher<TEntity>... matchers) {
		return anyOf(__mergeIndices(matchers));
	}

	@Override
	public INoneOfMatcher<TEntity> noneOf(int... indices) {
		__noneOfIndices = __distinctIndices(indices);
		__indices = null;
		__hashCached = false;
		return this;
	}

	@Override
	public INoneOfMatcher<TEntity> noneOf(@SuppressWarnings("rawtypes") IMatcher... matchers) {
		return noneOf(__mergeIndices(matchers));
	}

	@Override
	public boolean matches(IEntity entity) {
		boolean matchesAllOf = __allOfIndices == null || entity.hasComponents(__allOfIndices);
		boolean matchesAnyOf = __anyOfIndices == null || entity.hasAnyComponent(__anyOfIndices);
		boolean matchesNoneOf = __noneOfIndices == null || !entity.hasAnyComponent(__noneOfIndices);
		return matchesAllOf && matchesAnyOf && matchesNoneOf;
	}

	//------------------- Static ------------------------
	//---------------------------------------------------
	public static <TEntity extends IEntity> IAnyOfMatcher<TEntity> anyof(int... indices) {
		Matcher<TEntity> matcher = new Matcher<TEntity>();
		matcher.__anyOfIndices = __distinctIndices(indices);
		return matcher;
	}

	@SuppressWarnings("unchecked")
	public static <TEntity extends IEntity> IAnyOfMatcher<TEntity> anyof(IMatcher<TEntity>... matchers) {
		@SuppressWarnings("rawtypes") Matcher anyOfMatcher = (Matcher<TEntity>) Matcher.anyof(__mergeIndices(matchers));
		__setComponentNames(anyOfMatcher, matchers);
		return anyOfMatcher;
	}

	@SuppressWarnings({ "rawtypes", "unchecked" })
	public static <TEntity extends IEntity> IAllOfMatcher<TEntity> allof(int... indices) {
		Matcher matcher = new Matcher<TEntity>();
		matcher.__allOfIndices = __distinctIndices(indices);
		return matcher;
	}

	@SuppressWarnings({ "rawtypes", "unchecked" })
	public static <TEntity extends IEntity> IAllOfMatcher<TEntity> allof(IMatcher... matchers) {
		Matcher allOfMatcher = (Matcher<TEntity>) allof(__mergeIndices(matchers));
		__setComponentNames(allOfMatcher, matchers);
		return allOfMatcher;
	}

	private static int[] __mergeIndices(int[] allOfIndices, int[] anyOfIndices, int[] noneOfIndices) {
		List<Integer> indicesList = EntitasCache.getIntArray();

		if (allOfIndices != null) {
			for (int it : allOfIndices) {
				indicesList.add(it);
			}
		}
		if (anyOfIndices != null) {
			for (int it : anyOfIndices) {
				indicesList.add(it);
			}
		}
		if (noneOfIndices != null) {
			for (int it : noneOfIndices) {
				indicesList.add(it);
			}

		}
		int temp[] = new int[indicesList.size()];
		for (int i = 0; i < indicesList.size(); i++) {
			temp[i] = indicesList.get(i);
		}

		int[] mergeIndices = __distinctIndices(temp);
		EntitasCache.pushIntArray(indicesList);
		
		return mergeIndices;
	}

	@SuppressWarnings("rawtypes")
	private static int[] __mergeIndices(IMatcher... matchers) {
		int[] indices = new int[matchers.length];
		for (int i = 0; i < matchers.length; i++) {
			IMatcher matcher = matchers[i];
			if (matcher.getIndices().length != 1) {
				throw new MatcherException(matcher);
			}
			indices[i] = matcher.getIndices()[0];
		}

		return indices;
	}

	@SuppressWarnings("rawtypes")
	private static <TEntity extends IEntity> String[] __getComponentNames(IMatcher<TEntity>[] matchers) {
		for (int i = 0; i < matchers.length; i++) {
			Matcher matcher = (Matcher) matchers[i];
			if (matcher != null && matcher.componentNames != null) {
				return matcher.componentNames;
			}
		}

		return null;
	}

	private static <TEntity extends IEntity> void __setComponentNames(Matcher<TEntity> matcher, IMatcher<TEntity>[] matchers) {
		String[] componentNames = __getComponentNames(matchers);
		if (componentNames != null) {
			matcher.componentNames = componentNames;
		}
	}

	private static int[] __distinctIndices(int... indices) {
		Set<Integer> indicesSet = EntitasCache.getIntHashSet();
		for (int indice : indices) {
			indicesSet.add(indice);
		}
		int[] uniqueIndices = new int[indicesSet.size()];
		int i = 0;
		for (Integer ind : indicesSet) {
			uniqueIndices[i] = ind;
			i++;
		}
		Arrays.sort(uniqueIndices);
		EntitasCache.pushIntHashSet(indicesSet);
		
		return uniqueIndices;
	}

	//------------------- Equals ------------------------
	//---------------------------------------------------
	@Override
	public int hashCode() {
		if (!__hashCached) {
			int hash = getClass().hashCode();
			hash = __applyHash(hash, __allOfIndices, 3, 53);
			hash = __applyHash(hash, __anyOfIndices, 307, 367);
			hash = __applyHash(hash, __noneOfIndices, 647, 683);
			__hash = hash;
			__hashCached = true;
		}

		return __hash;
	}

	private static int __applyHash(int hash, int[] indices, int i1, int i2) {
		if (indices != null) {
			for (int i = 0, indicesLength = indices.length; i < indicesLength; i++) {
				hash ^= indices[i] * i1;
			}
			hash ^= indices.length * i2;
		}
		return hash;
	}

	@SuppressWarnings("unchecked")
	@Override
	public boolean equals(Object obj) {
		if (obj == null || obj.getClass() != getClass() || obj.hashCode() != hashCode()) {
			return false;
		}

		Matcher<TEntity> matcher = (Matcher<TEntity>) obj;
		if (!__equalIndices(matcher.getAllOfIndices(), __allOfIndices)) {
			return false;
		}
		if (!__equalIndices(matcher.getAnyOfIndices(), __anyOfIndices)) {
			return false;
		}
		if (!__equalIndices(matcher.getNoneOfIndices(), __noneOfIndices)) {
			return false;
		}

		return true;
	}

	private static boolean __equalIndices(int[] i1, int[] i2) {
		if ((i1 == null) != (i2 == null)) {
			return false;
		}
		if (i1 == null) {
			return true;
		}
		if (i1.length != i2.length) {
			return false;
		}

		for (int i = 0, indicesLength = i1.length; i < indicesLength; i++) {
			if (i1[i] != i2[i]) {
				return false;
			}
		}
		return true;

	}

	//------------------- Others ------------------------
	//---------------------------------------------------
	@Override
	public String toString() {
		return "Matcher{" + ", indices=" + __componentsToString(__indices) + ", allOfIndices=" + __componentsToString(__allOfIndices)
				+ ", anyOfIndices=" + __componentsToString(__anyOfIndices) + ", noneOfIndices=" + __componentsToString(__noneOfIndices)
				+ ", hash=" + __hash + '}';
	}

	private String __componentsToString(int[] indices) {
		StringBuilder builder = new StringBuilder();
		if (indices != null) {
			for (int i : indices) {
				builder.append(componentNames[i]);
			}
		}
		return builder.toString();
	}

}
